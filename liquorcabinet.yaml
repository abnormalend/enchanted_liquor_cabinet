esphome:
  name: liquorcabinet
  platform: ESP32
  board: esp32dev
  build_path: ./build


wifi:
  ssid: !secret ssid
  password: !secret wifipassword

  ap:
    ssid: "Liquor Cabinet Fallback Hotspot"
    password: !secret fallbackpassword

captive_portal:

# Enable logging
logger:
  baud_rate: 0    # don't log to the UART we're using for mp3

ota:

web_server:
  port: 80
 
light:
  - platform: neopixelbus
    type: GRB
    pin: 5 
    num_leds: 116
    name: "Neopixels"
    id: neopixels
    internal: true
  - platform: partition
    name: "Side 1 Top"
    id: side_1_top
    segments:
      - id: neopixels
        from: 0
        to: 15
    effects:
    - addressable_scan:
    - flicker:
    - addressable_twinkle:
    - addressable_rainbow:
    - addressable_fireworks:
  - platform: partition
    name: "Side 2 Top"
    id: side_2_top
    segments:
      - id: neopixels
        from: 58
        to: 73
    effects:
      - addressable_scan:
      - flicker:
      - addressable_twinkle:
      - addressable_rainbow:
      - addressable_fireworks:
  - platform: partition
    name: "Side 1 Main"
    id: side_1_main
    segments:
      - id: neopixels
        from: 16
        to: 57
    effects:
    - addressable_scan:
    - flicker:
    - addressable_twinkle:
    - addressable_rainbow:
    - addressable_fireworks:
  - platform: partition
    name: "Side 2 Main"
    id: side_2_main
    segments:
      - id: neopixels
        from: 74
        to: 115
    effects:
    - addressable_scan:
    - flicker:
    - addressable_twinkle:
    - addressable_rainbow:
    - addressable_fireworks:
    
binary_sensor:
  - platform: gpio
    pin:
      number: 15
      mode: INPUT_PULLUP
    name: "Side 1 Doors"
    device_class: door
    on_press:
      then:
        - script.execute: show_picker
    on_release:
      then:
        - delay: 600s
        - script.execute: lights_off
  - platform: gpio
    pin:
      number: 4
      mode: INPUT_PULLUP
    name: "Side 2 Doors"
    device_class: door
    on_press:
      then:
        - script.execute: show_picker
    on_release:
      then:
        - delay: 600s
        - script.execute: lights_off

switch:
  - platform: template
    name: "Mute"
    id: mute
    lambda: !lambda |-
      return id(mute_val);
    turn_on_action:
      - globals.set:
          id: mute_val
          value: '1'
    turn_off_action:
      - globals.set:
          id: mute_val
          value: '0'

uart:
  id: mp3uart
  tx_pin: GPIO1
  rx_pin: GPIO3
  baud_rate: 9600

# Declare DFPlayer mini module
dfplayer:
  id: mp3
  uart_id: mp3uart
  on_finished_playback:
    then:
      logger.log: 'Somebody press play!'

globals:
  - id: mute_val
    type: bool
    restore_value: yes
    initial_value: '0'

text_sensor:
  - platform: homeassistant
    name: 'show_mode'
    id: show_mode
    entity_id: input_select.liquorcabinet_mode
  - platform: homeassistant
    name: volume
    entity_id: input_number.liqourcabinet_volume
    filters:
      - lambda: return x.substr(0, x.size()-2);
    on_value:
      then:
        - dfplayer.set_volume: !lambda |-
            char *end;
            float value = ::strtof(x.c_str(), &end);
            if (end == nullptr || end != x.end().base())
              return {};
            return value;

script:
  - id: lights_on
    then:
      - light.turn_on: 
          id: side_1_top
          transition_length: 3s
          red: 100%
          green: 71%
          blue: 43%
          brightness: 100%
      - light.turn_on: 
          id: side_1_main
          transition_length: 3s
          red: 100%
          green: 71%
          blue: 43%
          brightness: 100%
      - light.turn_on: 
          id: side_2_top
          transition_length: 3s
          red: 100%
          green: 71%
          blue: 43%
          brightness: 100%
      - light.turn_on: 
          id: side_2_main
          transition_length: 3s
          red: 100%
          green: 71%
          blue: 43%
          brightness: 100%
  - id: lights_on_halloween
    then:
      - light.turn_on: 
          id: side_1_top
          transition_length: 3s
          red: 100%
          green: 50%
          blue: 0%
          brightness: 75%
      - light.turn_on: 
          id: side_1_main
          transition_length: 3s
          red: 50%
          green: 0%
          blue: 100%
          brightness: 75%
      - light.turn_on: 
          id: side_2_top
          transition_length: 3s
          red: 100%
          green: 50%
          blue: 0%
          brightness: 75%
      - light.turn_on: 
          id: side_2_main
          transition_length: 3s
          red: 50%
          green: 0%
          blue: 100%
          brightness: 75%
  - id: lights_off
    then:
      - light.turn_off: 
          id: side_1_top
          transition_length: 3s
      - light.turn_off: 
          id: side_1_main
          transition_length: 3s
      - light.turn_off: 
          id: side_2_top
          transition_length: 3s
      - light.turn_off: 
          id: side_2_main
          transition_length: 3s
  - id: show_picker
    then:
      - lambda: |-
          if (id(show_mode).state == "default") {
            id(default_show).execute();            
          }
          if (id(show_mode).state == "halloween") {
            id(halloween).execute();      
          }
          if (id(show_mode).state == "tiki room") {
            id(tiki_room).execute();      
          }
  - id: default_show
    then:
      - if:
          condition:
            switch.is_off: mute
          then:
            - dfplayer.play: !lambda |-
                return (rand() % 3) + 1;
      - script.execute: lights_on
  - id: halloween
    then:
      - if:
          condition:
            switch.is_off: mute
          then:
            - dfplayer.play: 5
      - script.execute: lights_on_halloween
  - id: tiki_room
    then:
      - if:
          condition:
            switch.is_off: mute
          then:
            - dfplayer.play: 4
      - script.execute: lights_on




# Enable Home Assistant API
api:
  services:
  - service: dfplayer_next
    then:
      - dfplayer.play_next:
  - service: dfplayer_previous
    then:
      - dfplayer.play_previous:
  - service: dfplayer_play
    variables:
      file: int
    then:
      - dfplayer.play: !lambda 'return file;'
  - service: dfplayer_play_loop
    variables:
      file: int
      loop_: bool
    then:
      - dfplayer.play:
          file: !lambda 'return file;'
          loop: !lambda 'return loop_;'
  - service: dfplayer_play_folder
    variables:
      folder: int
      file: int
    then:
      - dfplayer.play_folder:
          folder: !lambda 'return folder;'
          file: !lambda 'return file;'
  - service: dfplayer_play_loop_folder
    variables:
      folder: int
    then:
      - dfplayer.play_folder:
          folder: !lambda 'return folder;'
          loop: True
  - service: dfplayer_set_device_tf
    then:
      - dfplayer.set_device: TF_CARD
  - service: dfplayer_set_volume
    variables:
      volume: int
    then:
      - dfplayer.set_volume: !lambda 'return volume;'
  - service: dfplayer_set_eq
    variables:
      preset: int
    then:
      - dfplayer.set_eq: !lambda 'return static_cast<dfplayer::EqPreset>(preset);'
  - service: dfplayer_sleep
    then:
      - dfplayer.sleep
  - service: dfplayer_reset
    then:
      - dfplayer.reset
  - service: dfplayer_start
    then:
      - dfplayer.start
  - service: dfplayer_pause
    then:
      - dfplayer.pause
  - service: dfplayer_stop
    then:
      - dfplayer.stop
  - service: dfplayer_random
    then:
      - dfplayer.random